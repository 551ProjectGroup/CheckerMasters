#include <iostream>
#include <cstdlib>
#include <vector>
#include "boardstate.h"
#include <QMessageBox>

BoardState & BoardState::operator=(BoardState & rhs){
    if (this != &rhs){
        for (int i = 0; i < 8; i++){
            for (int j = 0; j < 8; j++){
                board[j][i] = rhs.board[j][i];
            }
        }
        moveCounter = rhs.moveCounter;
        userColor = rhs.userColor;
        compColor = rhs.compColor;
        turn = rhs.turn;
        startOfUserTurn = rhs.startOfUserTurn;
        lastX = rhs.lastX;
        lastY = rhs.lastY;
    }
    return *this;
}

int BoardState::checkMoveValue(int depth){
    if (depth < 1){
        int compValue = 0;
        int userValue = 0;
        int userKingX = 8;
        int userKingY = 8;
        int numberOfCloseKings = 0;
        for (int i = 0; i< 8; i++){
            for (int j = 0; j<8; j++){
                if (board[j][i].getPieceColor() == userColor && board[j][i].getType()==0){
                    if (i == 1){ //keeps piece from getting behind computers pieces and becoming a king
                        if (j == 0){
                            if (board[j+1][0].getEmpty() == 1){
                                userValue = userValue + 35 + ((7-i)%2);
                            }
                        }
                        else if ( j == 7){
                            if (board[j-1][0].getEmpty() == 1){
                                userValue = userValue + 35 + ((7-i)%2);
                            }
                        }
                        else{
                          if (board[j-1][0].getEmpty() == 1 && board[j+1][0].getEmpty() == 1){
                              userValue = userValue + 35 + ((7-i)%2);
                          }
                          else{
                              userValue = userValue + 30 + ((7-i)%2);
                          }
                        }
                    }
                    if (i == 2){//keeps piece from getting behind computers pieces and becoming a king
                        if (j == 0){
                            if (board[j+1][1].getEmpty() == 1 && board[j+2][0].getEmpty()==1 && board[j][0].getEmpty()==1){
                                userValue = userValue + 35 + ((7-i)%2);
                            }
                        }
                        else if (j == 1){
                            if (board[j-1][1].getEmpty()==1 && board[j+1][1].getEmpty() == 1 && board[j+2][0].getEmpty()==1 && board[j][0].getEmpty()==1){
                                userValue = userValue + 35 + ((7-i)%2);
                            }
                        }
                        else if (j == 6){
                            if (board[j-1][1].getEmpty()==1 && board[j+1][1].getEmpty() == 1 && board[j-2][0].getEmpty()==1 && board[j][0].getEmpty()==1){
                                userValue = userValue + 35 + ((7-i)%2);
                            }
                        }
                        else if (j == 7){
                            if (board[j-1][1].getEmpty()==1 && board[j-2][0].getEmpty()==1 && board[j][0].getEmpty()==1){
                                userValue = userValue + 35 + ((7-i)%2);
                            }
                        }
                        else{
                          if (board[j-1][1].getEmpty()==1 && board[j+2][0].getEmpty() ==1 && board[j+1][1].getEmpty() == 1 && board[j-2][0].getEmpty()==1 && board[j][0].getEmpty()==1){
                              userValue = userValue + 35 + ((7-i)%2);
                          }
                          else{
                              userValue = userValue + 30 + ((7-i)%2);
                          }
                        }
                    }
                    else{
                      userValue = userValue + 30 + ((7-i)%2);
                    }
                }
                if (board[j][i].getPieceColor() == userColor && board[j][i].getType()==1){
                    userValue = userValue + 40;
                    userKingX = j;
                    userKingY = i;
                }
                if (board[j][i].getPieceColor() == compColor && board[j][i].getType()==0){
                    compValue = compValue +30 + (i%2);
                }
                if (board[j][i].getPieceColor() == compColor && board[j][i].getType()==1){
                    compValue = compValue +40;
                    if (userKingX != 8){ //used to close the gap at the end of the game to allow comp to win
                        int distanceX = userKingX - j;
                        if (distanceX < 0){
                            distanceX = -distanceX;
                        }
                        int distanceY = userKingY - i;
                        if (distanceY < 0){
                            distanceY = -distanceY;
                        }
                        int distance;
                        if (distanceX > distanceY){
                            distance = distanceX;
                        }
                        else{
                            distance = distanceY;
                        }
                        if (distance > 3){
                            compValue += (7-distance) ;
                        }
                        else{
                            numberOfCloseKings++;
                            compValue += 3; //max points for reaching within two squares - no further points for moving farther away
                        }
                        compValue += (2*numberOfCloseKings);
                    }
                }
            }
        }
        return (userValue - compValue);
    }
    else{
        int checkPiece;
        if (turn == 0){
            checkPiece = userColor;
        }
        else{
            checkPiece = compColor;
        }
        allMoves * moves = new allMoves();
        moves->jArrNum = 0;
        moves->rArrNum = 0;
        PossibleMoves(moves, checkPiece);
        if (moves->jArrNum == 0 && moves->rArrNum == 0){
            if (turn == 0){
                return -1000;
            }
            else{
                return 1000;
            }
        }
        if (moves->jArrNum == 0){
            int best;
            if (turn == 0){
                best = -1000;
            }
            else{
                best = 1000;
            }
            for (int i = 0; i < moves->rArrNum; i++){
                BoardState newCopy = *this;
                newCopy.updateBoard(moves->regArray[i]);
                newCopy.changeTurn();
                int result = checkMoveValue(depth - 1);
                if (result > 900){ // if the move is a winning move, move loses value the more moves it takes to win
                    result--;
                }
                if (result < -900){
                    result++;
                }
                if (turn == 0 && (result > best)){
                    best = result;
                }
                else if(turn == 1 && (result < best)){
                    best = result;
                }
            }
            return best;
        }
        else{
            jumpCompare best;
            if (turn == 0){
                best.value = -1000;
            }
            else{
                best.value = 1000;
            }
            for (int i = 0; i < moves->jArrNum; i++){
                BoardState newCopy = *this;
                jumpCompare result = newCopy.detJumpOrder(moves->jumpArray[i], depth);
                if (result.value > 900){ // if the move is a winning move, move loses value the more moves it takes to win
                    result.value--;
                }
                if (result.value < -900){
                    result.value++;
                }
                if (turn == 0 && (result.value > best.value)){
                    best = result;
                }
                else if(turn == 1 && (result.value < best.value)){
                    best = result;
                }
            }
            return best.value;
        }
    }
}

jumpCompare BoardState::detJumpOrder(UserInput & currentMove, int depth){
    jumpCompare end;
    end.jumpOrder.push_back(currentMove);
    end.jOrderSize = 1;
    BoardState updated = *this;
    updated.updateBoard(currentMove);
    return updated.detJumpOrderHelper(end, depth);
}

jumpCompare BoardState::detJumpOrderHelper(jumpCompare lowerMove, int depth){
    //bool further = checkFurther(lowerMove.jumpOrder[jOrderSize-1]);
    int checkPiece;
    if (turn == 0){
        checkPiece = userColor;
    }
    else{
        checkPiece = compColor;
    }
    allMoves * moves = new allMoves();
    moves->jArrNum = 0;
    moves->rArrNum = 0;
    PossibleMoves(moves, checkPiece);
    if (moves->jArrNum == 0){
        changeTurn();
        //Value recursion
        int moveValue = checkMoveValue(depth - 1);
        //return jumpCompare
        lowerMove.value = moveValue;
        return lowerMove;
    }
    else{
        jumpCompare best;
        if (turn == 0){
            best.value = -1000;
        }
        else{
            best.value = 1000;
        }
        for(int i = 0; i < moves->jArrNum; i++){
          BoardState newCopy = *this;
          newCopy.updateBoard(moves->jumpArray[i]);
          jumpCompare jCopy = lowerMove;
          jCopy.jOrderSize++;
          jCopy.jumpOrder.push_back(moves->jumpArray[i]);
          jumpCompare result = newCopy.detJumpOrderHelper(jCopy, depth);
          if (turn == 0 && (result.value > best.value)){
              best = result;
          }
          else if(turn == 1 && (result.value < best.value)){
              best = result;
          }
        }
        return best;
    }
}


void BoardState::emptyBoard(){
    for (int i = 0; i<8; i++){
        for (int j = 0; j<8; j++){
            Piece * newPiece = new Piece();
            board[j][i] = *newPiece;
        }
    }
}

bool BoardState::winLoss(void){
    int checkPiece;
    if (turn == 0){
        checkPiece = userColor;
    }
    else{
        checkPiece = compColor;
    }
    allMoves * moves = new allMoves();
    //comp->jumpArray = new UserInput*();
    moves->jArrNum = 0;
    moves->rArrNum = 0;
    PossibleMoves(moves, checkPiece);
    if (moves->jArrNum == 0 && moves->rArrNum == 0){
        return true;
    }
    else{
        return false;
    }
}

void BoardState::changeStep(int change, int x, int y){
    startOfUserTurn = change;
    lastX = x;
    lastY = y;
}

int BoardState::getStartOfUserTurn(void){
    return startOfUserTurn;
}

int BoardState::getLastY(void){
    return lastY;
}

int BoardState::getLastX(void){
    return lastX;
}

int BoardState::getCompColor(void){
    return compColor;
}

int BoardState::getMoveCounter(void){
    return moveCounter;
}

void BoardState::changeTurn(void){
  moveCounter++;
  startOfUserTurn = 0;
  if (board[lastX][lastY].getUpgrade() == 1){
    Piece * update = new Piece(board[lastX][lastY].getPieceColor(), 1, 0);
    board[lastX][lastY] = *update;
    delete update;
  }
  if (turn == 1){
    turn = 0;
  }
  else{
    turn = 1;
  }
}

Piece BoardState::getPiece(int x, int y){
  return board[x][y];
}

bool BoardState::checkLegalJump(UserInput & input){
  int nY = input.getNext().y;
  int nX = input.getNext().x;
  int cY = input.getCurrent().y;
  int cX = input.getCurrent().x;
  if ((cY - nY == 2) || (cY - nY == -2)){
    if ((cX - nX == 2) || (cX - nX == -2)){
      if (board[cX][cY].getType() == 1){
    if (board[nX][nY].getEmpty() != 1){
      return false;
    }
    if (board[cX - ((cX - nX) /2)][cY - ((cY - nY)/2)].getPieceColor() == compColor){
      return true;
    }
    else{
      return false;
    }
      }
      else{ //check normal piece
    if (nY - cY == 2){
      return false; //if going backwards
    }
    else{
      if (board[nX][nY].getEmpty() != 1){
        return false;
      }
      if (board[cX - ((cX - nX) /2)][cY - ((cY - nY)/2)].getPieceColor() == compColor){
        return true;
      }
      else{
        return false;
      }
    }
      }
    }
    else{
      return false;
    }
  }
  else{
    return false;
  }
}
bool BoardState::checkNoJumps(){
  for(int i = 0; i < 8; i++){
    for(int j =0; j <8; j++){
      if (board[i][j].getPieceColor() == userColor && board[i][j].getEmpty() != 1){
    if (j>1){
      if ( i > 1){
        if (board[i-1][j-1].getPieceColor() == compColor && board[i-2][j-2].getEmpty() == 1){
          return false;
        }
      }
      if ( i < 6){
        if (board[i+1][j-1].getPieceColor() == compColor && board[i+2][j-2].getEmpty() == 1){
          return false;
        }
      }
    }
    if (j<6 && board[i][j].getType() == 1){
      if ( i > 1){
        if (board[i-1][j+1].getPieceColor() == compColor && board[i-2][j+2].getEmpty() == 1){
          return false;
        }
      }
      if ( i < 6){
        if (board[i+1][j+1].getPieceColor() == compColor && board[i+2][j+2].getEmpty() == 1){
          return false;
        }
      }
    }
      }
    }
  }
  return true;
}
bool BoardState::checkRegMove(UserInput & Input){
  int nY = Input.getNext().y;
  int nX = Input.getNext().x;
  int cY = Input.getCurrent().y;
  int cX = Input.getCurrent().x;
  if ((cY - nY == 1) || (cY - nY == -1)){
    if ((cX - nX == 1) || (cX - nX == -1)){
      if (board[cX][cY].getType() == 1){
    if (board[nX][nY].getEmpty() != 1){
      return false;
    }
    return true;
      }
      else{ //regular piece
    if (nY - cY == 1){ //going backward
      return false;
    }
    if (board[nX][nY].getEmpty() != 1){
      return false;
    }
    return true;
      }
    }
  }
  return false;
}

bool BoardState::checkLegality(UserInput & input){
  if (board[input.getCurrent().x][input.getCurrent().y].getPieceColor() != userColor){
    return false;
  }
  //check jump
  bool jump = checkLegalJump(input);
  if (jump == true){
    return true;
  }
  else{
    bool regMove = checkRegMove(input);
    if (regMove == true){
      bool noJump = checkNoJumps();
      if (noJump == true){
    return true;
      }
      else{
    return false;
      }
    }
    else{
      return false;
    }
  }
}

int BoardState::getTurn(void){
  return turn;
}

BoardState::BoardState(int color){
  startOfUserTurn = 0;
  lastX = 0;
  lastY = 0;
  turn = color;
  userColor = color;
  moveCounter = 0;
  if (color == 1){
    compColor = 0;
  }
  else{
    compColor = 1;
  }
  for(int i = 0; i < 8; i=i+2){
    for(int j = 0; j < 8; j=j+2){
      Piece * newPiece = new Piece();
      board[j][i] = *newPiece;
    }
  }
  for(int i = 1; i < 8; i=i+2){
    for(int j = 1; j < 8; j=j+2){
      Piece * newPiece = new Piece();
      board[j][i] = *newPiece;
    }
  }
  for (int j = 0; j < 8; j=j+2){
    Piece * newPiece = new Piece();
    board[j][3] = *newPiece;
  }
  for (int j = 1; j < 8; j=j+2){
    Piece * newPiece = new Piece();
    board[j][4] = *newPiece;
  }
  for (int i = 5; i < 8; i = i+2){
    for (int j = 0; j < 8; j= j+2){
      Piece * userPiece = new Piece(color);
      board[j][i] = *userPiece;
    }
  }
  for(int j = 1; j< 8; j=j+2){
    Piece * userPiece = new Piece(color);
    board[j][6] = *userPiece;
  }
  for (int i = 0; i < 3; i = i+2){
    for (int j = 1; j < 8; j= j+2){
      Piece * computerPiece = new Piece(compColor);
      board[j][i] = *computerPiece;
    }
  }
  for(int j = 0; j< 8; j=j+2){
    Piece * computerPiece = new Piece(compColor);
    board[j][1] = *computerPiece;
  }
}

void BoardState::updateBoard(UserInput & input){
  int nY = input.getNext().y;
  int nX = input.getNext().x;
  int cY = input.getCurrent().y;
  int cX = input.getCurrent().x;
  lastX = nX;
  lastY = nY;
  if (board[cX][cY].getPieceColor() == userColor){
    if (nY == 0 && board[cX][cY].getType() != 1){
      Piece * update = new Piece(board[cX][cY].getPieceColor(), 1, 1);
      board[nX][nY] = *update;
      delete update;
    }
    else{
      board[nX][nY] = board[cX][cY];
    }
  }
  if (board[cX][cY].getPieceColor() == compColor){
    if (nY == 7 && board[cX][cY].getType() != 1){
      Piece * update = new Piece(board[cX][cY].getPieceColor(), 1, 1);
      board[nX][nY] = *update;
      delete update;
    }
    else{
      board[nX][nY] = board[cX][cY];
    }
  }
  //sets empty piece to old current square
  Piece * newPiece = new Piece();
  board[cX][cY] = *newPiece;
  delete newPiece;
  //deletes middle piece in a jump
  if (cX - nX == -2 || cX - nX == 2){
    startOfUserTurn = 1; //sets the middle of the turn -- used for both computer and user
    Piece * deletePiece = new Piece();
    board[cX - ((cX - nX) /2)][cY - ((cY - nY)/2)] = *deletePiece;
    delete deletePiece;
  }
}

bool BoardState::checkFurther(UserInput & input){
  int nY = input.getNext().y;
  int nX = input.getNext().x;
  //int cY = input.getCurrent().y;
  int cX = input.getCurrent().x;
  int opponentColor;
  if (turn == 0){
    opponentColor = compColor;
  }
  else{
    opponentColor = userColor;
  }
  if (board[nX][nY].getUpgrade() == 1){
    Piece * update = new Piece(board[nX][nY].getPieceColor(), 1, 0);
    board[nX][nY] = *update;
    delete update;
    return false;
  }
  if (cX - nX == 1 || cX - nX == -1){
    return false;
  }
  if ((nY > 1 && board[nX][nY].getType() == 1) || (nY>1 && opponentColor == compColor)){
    if ( nX > 1){
      if (board[nX-1][nY-1].getPieceColor() == opponentColor && board[nX-2][nY-2].getEmpty() == 1){
    return true;
      }
    }
    if ( nX < 6){
      if (board[nX+1][nY-1].getPieceColor() == opponentColor && board[nX+2][nY-2].getEmpty() == 1){
    return true;
      }
    }
  }
  if ((nY <6 && board[nX][nY].getType() == 1) || (nY < 6 && opponentColor == userColor)){
    if ( nX > 1){
      if (board[nX-1][nY+1].getPieceColor() == opponentColor && board[nX-2][nY+2].getEmpty() == 1){
    return true;
      }
    }
    if ( nX < 6){
      if (board[nX+1][nY+1].getPieceColor() == opponentColor && board[nX+2][nY+2].getEmpty() == 1){
    return true;
      }
    }
  }
  return false;
}

UserInput * BoardState::comMoreMove(Coor start){
  std::vector<Coor> nextSquare;
  int size = 0;
  Coor current = start;
  Coor next;
  int j = current.x;
  int i = current.y;
  if (i < 6){
    if ( j > 1){
      if (board[j-1][i+1].getPieceColor() == userColor && board[j-2][i+2].getEmpty() == 1){
    next.x = j-2;
    next.y = i+2;
    nextSquare.push_back(next);
    size++;
      }
    }
    if ( j < 6){
      if (board[j+1][i+1].getPieceColor() == userColor && board[j+2][i+2].getEmpty() == 1){
    next.x = j+2;
    next.y = i+2;
    nextSquare.push_back(next);
    size++;
      }
    }
  }
  if (i > 1 && board[j][i].getType() == 1){
    if ( j > 1){
      if (board[j-1][i-1].getPieceColor() == userColor && board[j-2][i-2].getEmpty() == 1){
    next.x = j-2;
    next.y = i-2;
    nextSquare.push_back(next);
    size++;
      }
    }
    if ( j < 6){
      if (board[j+1][i-1].getPieceColor() == userColor && board[j+2][i-2].getEmpty() == 1){
    next.x = j+2;
    next.y = i-2;
    nextSquare.push_back(next);
    size++;
      }
    }
  }
  int randomMove = rand() % size;
  next = nextSquare[randomMove];
  UserInput * nextMove = new UserInput(0, current, next);
  return nextMove;
}

void BoardState::PossibleMoves(allMoves * comp, int checkColor){
   int opponentColor;
   if (checkColor == 0){
       opponentColor = 1;
   }
   else{
       opponentColor = 0;
   }
   for (int i = 0; i < 8; i++){
    for (int j = 0; j< 8; j++){
      if ((startOfUserTurn == 1 && j == lastX && i == lastY) || startOfUserTurn == 0){
        if (board[j][i].getPieceColor() == checkColor && board[j][i].getUpgrade() == 0){
        Coor current;
        Coor next;
        current.x = j;
        current.y = i;
        if (i < 6 && (board[j][i].getType() == 1 || board[j][i].getPieceColor() == compColor)){
            if ( j > 1){
                if (board[j-1][i+1].getPieceColor() == opponentColor && board[j-2][i+2].getEmpty() == 1){
                    next.x = j-2;
                    next.y = i+2;
                    UserInput * newElement = new UserInput(0, current, next);
                    (comp->jumpArray).push_back(*newElement);
                    comp->jArrNum++;
                }
            }
      if ( j < 6){
        if (board[j+1][i+1].getPieceColor() == opponentColor && board[j+2][i+2].getEmpty() == 1){
          next.x = j+2;
          next.y = i+2;
          UserInput * newElement = new UserInput(0, current, next);
          (comp->jumpArray).push_back(*newElement);
          comp->jArrNum++;
        }
      }
    }
    if (i > 1 && (board[j][i].getType() == 1 || board[j][i].getPieceColor() == userColor)){
      if ( j > 1){
        if (board[j-1][i-1].getPieceColor() == opponentColor && board[j-2][i-2].getEmpty() == 1){
          next.x = j-2;
          next.y = i-2;
          UserInput * newElement = new UserInput(0, current, next);
          (comp->jumpArray).push_back(*newElement);
          comp->jArrNum++;
        }
      }
      if ( j < 6){
        if (board[j+1][i-1].getPieceColor() == opponentColor && board[j+2][i-2].getEmpty() == 1){
          next.x = j+2;
          next.y = i-2;
          UserInput * newElement = new UserInput(0, current, next);
          (comp->jumpArray).push_back(*newElement);
          comp->jArrNum++;
        }
      }
    }
    if (i <7 && (board[j][i].getType() == 1 || board[j][i].getPieceColor() == compColor)){ // moving to regular moves
        if ( j > 0){
          if (board[j-1][i+1].getEmpty() == 1){
            next.x = j-1;
            next.y = i+1;
            UserInput * newElement = new UserInput(0, current, next);
            (comp->regArray).push_back(*newElement);
            comp->rArrNum++;
            }
          }
        if ( j < 7){
            if (board[j+1][i+1].getEmpty() == 1){
                next.x = j+1;
                next.y = i+1;
                UserInput * newElement = new UserInput(0, current, next);
                (comp->regArray).push_back(*newElement);
                comp->rArrNum++;
            }
        }
      }
    if (i > 0 && (board[j][i].getType() == 1 || board[j][i].getPieceColor() == userColor)){
      if ( j > 0){
        if (board[j-1][i-1].getEmpty() == 1){
          next.x = j-1;
          next.y = i-1;
          UserInput * newElement = new UserInput(0, current, next);
          (comp->regArray).push_back(*newElement);
          comp->rArrNum++;
        }
      }
      if ( j < 7){
        if (board[j+1][i-1].getEmpty() == 1){
          next.x = j+1;
          next.y = i-1;
          UserInput * newElement = new UserInput(0, current, next);
          (comp->regArray).push_back(*newElement);
          comp->rArrNum++;
        }
      }
        }
        }
      }
  }
  }
}
